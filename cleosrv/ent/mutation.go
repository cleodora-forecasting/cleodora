// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/estimate"
	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/forecast"
	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/outcome"
	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/predicate"
	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/probability"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEstimate    = "Estimate"
	TypeForecast    = "Forecast"
	TypeOutcome     = "Outcome"
	TypeProbability = "Probability"
)

// EstimateMutation represents an operation that mutates the Estimate nodes in the graph.
type EstimateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	reason               *string
	created              *time.Time
	clearedFields        map[string]struct{}
	forecast             *int
	clearedforecast      bool
	probabilities        map[int]struct{}
	removedprobabilities map[int]struct{}
	clearedprobabilities bool
	done                 bool
	oldValue             func(context.Context) (*Estimate, error)
	predicates           []predicate.Estimate
}

var _ ent.Mutation = (*EstimateMutation)(nil)

// estimateOption allows management of the mutation configuration using functional options.
type estimateOption func(*EstimateMutation)

// newEstimateMutation creates new mutation for the Estimate entity.
func newEstimateMutation(c config, op Op, opts ...estimateOption) *EstimateMutation {
	m := &EstimateMutation{
		config:        c,
		op:            op,
		typ:           TypeEstimate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstimateID sets the ID field of the mutation.
func withEstimateID(id int) estimateOption {
	return func(m *EstimateMutation) {
		var (
			err   error
			once  sync.Once
			value *Estimate
		)
		m.oldValue = func(ctx context.Context) (*Estimate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Estimate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstimate sets the old Estimate of the mutation.
func withEstimate(node *Estimate) estimateOption {
	return func(m *EstimateMutation) {
		m.oldValue = func(context.Context) (*Estimate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstimateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstimateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EstimateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EstimateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Estimate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReason sets the "reason" field.
func (m *EstimateMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *EstimateMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *EstimateMutation) ResetReason() {
	m.reason = nil
}

// SetCreated sets the "created" field.
func (m *EstimateMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *EstimateMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *EstimateMutation) ResetCreated() {
	m.created = nil
}

// SetForecastID sets the "forecast" edge to the Forecast entity by id.
func (m *EstimateMutation) SetForecastID(id int) {
	m.forecast = &id
}

// ClearForecast clears the "forecast" edge to the Forecast entity.
func (m *EstimateMutation) ClearForecast() {
	m.clearedforecast = true
}

// ForecastCleared reports if the "forecast" edge to the Forecast entity was cleared.
func (m *EstimateMutation) ForecastCleared() bool {
	return m.clearedforecast
}

// ForecastID returns the "forecast" edge ID in the mutation.
func (m *EstimateMutation) ForecastID() (id int, exists bool) {
	if m.forecast != nil {
		return *m.forecast, true
	}
	return
}

// ForecastIDs returns the "forecast" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ForecastID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) ForecastIDs() (ids []int) {
	if id := m.forecast; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetForecast resets all changes to the "forecast" edge.
func (m *EstimateMutation) ResetForecast() {
	m.forecast = nil
	m.clearedforecast = false
}

// AddProbabilityIDs adds the "probabilities" edge to the Probability entity by ids.
func (m *EstimateMutation) AddProbabilityIDs(ids ...int) {
	if m.probabilities == nil {
		m.probabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.probabilities[ids[i]] = struct{}{}
	}
}

// ClearProbabilities clears the "probabilities" edge to the Probability entity.
func (m *EstimateMutation) ClearProbabilities() {
	m.clearedprobabilities = true
}

// ProbabilitiesCleared reports if the "probabilities" edge to the Probability entity was cleared.
func (m *EstimateMutation) ProbabilitiesCleared() bool {
	return m.clearedprobabilities
}

// RemoveProbabilityIDs removes the "probabilities" edge to the Probability entity by IDs.
func (m *EstimateMutation) RemoveProbabilityIDs(ids ...int) {
	if m.removedprobabilities == nil {
		m.removedprobabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.probabilities, ids[i])
		m.removedprobabilities[ids[i]] = struct{}{}
	}
}

// RemovedProbabilities returns the removed IDs of the "probabilities" edge to the Probability entity.
func (m *EstimateMutation) RemovedProbabilitiesIDs() (ids []int) {
	for id := range m.removedprobabilities {
		ids = append(ids, id)
	}
	return
}

// ProbabilitiesIDs returns the "probabilities" edge IDs in the mutation.
func (m *EstimateMutation) ProbabilitiesIDs() (ids []int) {
	for id := range m.probabilities {
		ids = append(ids, id)
	}
	return
}

// ResetProbabilities resets all changes to the "probabilities" edge.
func (m *EstimateMutation) ResetProbabilities() {
	m.probabilities = nil
	m.clearedprobabilities = false
	m.removedprobabilities = nil
}

// Where appends a list predicates to the EstimateMutation builder.
func (m *EstimateMutation) Where(ps ...predicate.Estimate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EstimateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EstimateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Estimate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EstimateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EstimateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Estimate).
func (m *EstimateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EstimateMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.reason != nil {
		fields = append(fields, estimate.FieldReason)
	}
	if m.created != nil {
		fields = append(fields, estimate.FieldCreated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EstimateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estimate.FieldReason:
		return m.Reason()
	case estimate.FieldCreated:
		return m.Created()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EstimateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estimate.FieldReason:
		return m.OldReason(ctx)
	case estimate.FieldCreated:
		return m.OldCreated(ctx)
	}
	return nil, fmt.Errorf("unknown Estimate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estimate.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case estimate.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	}
	return fmt.Errorf("unknown Estimate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EstimateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EstimateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Estimate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EstimateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EstimateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstimateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Estimate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EstimateMutation) ResetField(name string) error {
	switch name {
	case estimate.FieldReason:
		m.ResetReason()
		return nil
	case estimate.FieldCreated:
		m.ResetCreated()
		return nil
	}
	return fmt.Errorf("unknown Estimate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EstimateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.forecast != nil {
		edges = append(edges, estimate.EdgeForecast)
	}
	if m.probabilities != nil {
		edges = append(edges, estimate.EdgeProbabilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EstimateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case estimate.EdgeForecast:
		if id := m.forecast; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgeProbabilities:
		ids := make([]ent.Value, 0, len(m.probabilities))
		for id := range m.probabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EstimateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprobabilities != nil {
		edges = append(edges, estimate.EdgeProbabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EstimateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case estimate.EdgeProbabilities:
		ids := make([]ent.Value, 0, len(m.removedprobabilities))
		for id := range m.removedprobabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EstimateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedforecast {
		edges = append(edges, estimate.EdgeForecast)
	}
	if m.clearedprobabilities {
		edges = append(edges, estimate.EdgeProbabilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EstimateMutation) EdgeCleared(name string) bool {
	switch name {
	case estimate.EdgeForecast:
		return m.clearedforecast
	case estimate.EdgeProbabilities:
		return m.clearedprobabilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EstimateMutation) ClearEdge(name string) error {
	switch name {
	case estimate.EdgeForecast:
		m.ClearForecast()
		return nil
	}
	return fmt.Errorf("unknown Estimate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EstimateMutation) ResetEdge(name string) error {
	switch name {
	case estimate.EdgeForecast:
		m.ResetForecast()
		return nil
	case estimate.EdgeProbabilities:
		m.ResetProbabilities()
		return nil
	}
	return fmt.Errorf("unknown Estimate edge %s", name)
}

// ForecastMutation represents an operation that mutates the Forecast nodes in the graph.
type ForecastMutation struct {
	config
	op               Op
	typ              string
	id               *int
	title            *string
	description      *string
	created          *time.Time
	resolves         *time.Time
	closes           *time.Time
	resolution       *forecast.Resolution
	clearedFields    map[string]struct{}
	estimates        map[int]struct{}
	removedestimates map[int]struct{}
	clearedestimates bool
	done             bool
	oldValue         func(context.Context) (*Forecast, error)
	predicates       []predicate.Forecast
}

var _ ent.Mutation = (*ForecastMutation)(nil)

// forecastOption allows management of the mutation configuration using functional options.
type forecastOption func(*ForecastMutation)

// newForecastMutation creates new mutation for the Forecast entity.
func newForecastMutation(c config, op Op, opts ...forecastOption) *ForecastMutation {
	m := &ForecastMutation{
		config:        c,
		op:            op,
		typ:           TypeForecast,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withForecastID sets the ID field of the mutation.
func withForecastID(id int) forecastOption {
	return func(m *ForecastMutation) {
		var (
			err   error
			once  sync.Once
			value *Forecast
		)
		m.oldValue = func(ctx context.Context) (*Forecast, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Forecast.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withForecast sets the old Forecast of the mutation.
func withForecast(node *Forecast) forecastOption {
	return func(m *ForecastMutation) {
		m.oldValue = func(context.Context) (*Forecast, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ForecastMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ForecastMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ForecastMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ForecastMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Forecast.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ForecastMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ForecastMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ForecastMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ForecastMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ForecastMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ForecastMutation) ResetDescription() {
	m.description = nil
}

// SetCreated sets the "created" field.
func (m *ForecastMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ForecastMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ForecastMutation) ResetCreated() {
	m.created = nil
}

// SetResolves sets the "resolves" field.
func (m *ForecastMutation) SetResolves(t time.Time) {
	m.resolves = &t
}

// Resolves returns the value of the "resolves" field in the mutation.
func (m *ForecastMutation) Resolves() (r time.Time, exists bool) {
	v := m.resolves
	if v == nil {
		return
	}
	return *v, true
}

// OldResolves returns the old "resolves" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldResolves(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolves is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolves requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolves: %w", err)
	}
	return oldValue.Resolves, nil
}

// ResetResolves resets all changes to the "resolves" field.
func (m *ForecastMutation) ResetResolves() {
	m.resolves = nil
}

// SetCloses sets the "closes" field.
func (m *ForecastMutation) SetCloses(t time.Time) {
	m.closes = &t
}

// Closes returns the value of the "closes" field in the mutation.
func (m *ForecastMutation) Closes() (r time.Time, exists bool) {
	v := m.closes
	if v == nil {
		return
	}
	return *v, true
}

// OldCloses returns the old "closes" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldCloses(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloses: %w", err)
	}
	return oldValue.Closes, nil
}

// ClearCloses clears the value of the "closes" field.
func (m *ForecastMutation) ClearCloses() {
	m.closes = nil
	m.clearedFields[forecast.FieldCloses] = struct{}{}
}

// ClosesCleared returns if the "closes" field was cleared in this mutation.
func (m *ForecastMutation) ClosesCleared() bool {
	_, ok := m.clearedFields[forecast.FieldCloses]
	return ok
}

// ResetCloses resets all changes to the "closes" field.
func (m *ForecastMutation) ResetCloses() {
	m.closes = nil
	delete(m.clearedFields, forecast.FieldCloses)
}

// SetResolution sets the "resolution" field.
func (m *ForecastMutation) SetResolution(f forecast.Resolution) {
	m.resolution = &f
}

// Resolution returns the value of the "resolution" field in the mutation.
func (m *ForecastMutation) Resolution() (r forecast.Resolution, exists bool) {
	v := m.resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldResolution returns the old "resolution" field's value of the Forecast entity.
// If the Forecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForecastMutation) OldResolution(ctx context.Context) (v forecast.Resolution, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolution: %w", err)
	}
	return oldValue.Resolution, nil
}

// ResetResolution resets all changes to the "resolution" field.
func (m *ForecastMutation) ResetResolution() {
	m.resolution = nil
}

// AddEstimateIDs adds the "estimates" edge to the Estimate entity by ids.
func (m *ForecastMutation) AddEstimateIDs(ids ...int) {
	if m.estimates == nil {
		m.estimates = make(map[int]struct{})
	}
	for i := range ids {
		m.estimates[ids[i]] = struct{}{}
	}
}

// ClearEstimates clears the "estimates" edge to the Estimate entity.
func (m *ForecastMutation) ClearEstimates() {
	m.clearedestimates = true
}

// EstimatesCleared reports if the "estimates" edge to the Estimate entity was cleared.
func (m *ForecastMutation) EstimatesCleared() bool {
	return m.clearedestimates
}

// RemoveEstimateIDs removes the "estimates" edge to the Estimate entity by IDs.
func (m *ForecastMutation) RemoveEstimateIDs(ids ...int) {
	if m.removedestimates == nil {
		m.removedestimates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.estimates, ids[i])
		m.removedestimates[ids[i]] = struct{}{}
	}
}

// RemovedEstimates returns the removed IDs of the "estimates" edge to the Estimate entity.
func (m *ForecastMutation) RemovedEstimatesIDs() (ids []int) {
	for id := range m.removedestimates {
		ids = append(ids, id)
	}
	return
}

// EstimatesIDs returns the "estimates" edge IDs in the mutation.
func (m *ForecastMutation) EstimatesIDs() (ids []int) {
	for id := range m.estimates {
		ids = append(ids, id)
	}
	return
}

// ResetEstimates resets all changes to the "estimates" edge.
func (m *ForecastMutation) ResetEstimates() {
	m.estimates = nil
	m.clearedestimates = false
	m.removedestimates = nil
}

// Where appends a list predicates to the ForecastMutation builder.
func (m *ForecastMutation) Where(ps ...predicate.Forecast) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ForecastMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ForecastMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Forecast, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ForecastMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ForecastMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Forecast).
func (m *ForecastMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ForecastMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, forecast.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, forecast.FieldDescription)
	}
	if m.created != nil {
		fields = append(fields, forecast.FieldCreated)
	}
	if m.resolves != nil {
		fields = append(fields, forecast.FieldResolves)
	}
	if m.closes != nil {
		fields = append(fields, forecast.FieldCloses)
	}
	if m.resolution != nil {
		fields = append(fields, forecast.FieldResolution)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ForecastMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case forecast.FieldTitle:
		return m.Title()
	case forecast.FieldDescription:
		return m.Description()
	case forecast.FieldCreated:
		return m.Created()
	case forecast.FieldResolves:
		return m.Resolves()
	case forecast.FieldCloses:
		return m.Closes()
	case forecast.FieldResolution:
		return m.Resolution()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ForecastMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case forecast.FieldTitle:
		return m.OldTitle(ctx)
	case forecast.FieldDescription:
		return m.OldDescription(ctx)
	case forecast.FieldCreated:
		return m.OldCreated(ctx)
	case forecast.FieldResolves:
		return m.OldResolves(ctx)
	case forecast.FieldCloses:
		return m.OldCloses(ctx)
	case forecast.FieldResolution:
		return m.OldResolution(ctx)
	}
	return nil, fmt.Errorf("unknown Forecast field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForecastMutation) SetField(name string, value ent.Value) error {
	switch name {
	case forecast.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case forecast.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case forecast.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case forecast.FieldResolves:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolves(v)
		return nil
	case forecast.FieldCloses:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloses(v)
		return nil
	case forecast.FieldResolution:
		v, ok := value.(forecast.Resolution)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolution(v)
		return nil
	}
	return fmt.Errorf("unknown Forecast field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ForecastMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ForecastMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForecastMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Forecast numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ForecastMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(forecast.FieldCloses) {
		fields = append(fields, forecast.FieldCloses)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ForecastMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ForecastMutation) ClearField(name string) error {
	switch name {
	case forecast.FieldCloses:
		m.ClearCloses()
		return nil
	}
	return fmt.Errorf("unknown Forecast nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ForecastMutation) ResetField(name string) error {
	switch name {
	case forecast.FieldTitle:
		m.ResetTitle()
		return nil
	case forecast.FieldDescription:
		m.ResetDescription()
		return nil
	case forecast.FieldCreated:
		m.ResetCreated()
		return nil
	case forecast.FieldResolves:
		m.ResetResolves()
		return nil
	case forecast.FieldCloses:
		m.ResetCloses()
		return nil
	case forecast.FieldResolution:
		m.ResetResolution()
		return nil
	}
	return fmt.Errorf("unknown Forecast field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ForecastMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.estimates != nil {
		edges = append(edges, forecast.EdgeEstimates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ForecastMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case forecast.EdgeEstimates:
		ids := make([]ent.Value, 0, len(m.estimates))
		for id := range m.estimates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ForecastMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedestimates != nil {
		edges = append(edges, forecast.EdgeEstimates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ForecastMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case forecast.EdgeEstimates:
		ids := make([]ent.Value, 0, len(m.removedestimates))
		for id := range m.removedestimates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ForecastMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedestimates {
		edges = append(edges, forecast.EdgeEstimates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ForecastMutation) EdgeCleared(name string) bool {
	switch name {
	case forecast.EdgeEstimates:
		return m.clearedestimates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ForecastMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Forecast unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ForecastMutation) ResetEdge(name string) error {
	switch name {
	case forecast.EdgeEstimates:
		m.ResetEstimates()
		return nil
	}
	return fmt.Errorf("unknown Forecast edge %s", name)
}

// OutcomeMutation represents an operation that mutates the Outcome nodes in the graph.
type OutcomeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	text                 *string
	correct              *bool
	clearedFields        map[string]struct{}
	probabilities        map[int]struct{}
	removedprobabilities map[int]struct{}
	clearedprobabilities bool
	done                 bool
	oldValue             func(context.Context) (*Outcome, error)
	predicates           []predicate.Outcome
}

var _ ent.Mutation = (*OutcomeMutation)(nil)

// outcomeOption allows management of the mutation configuration using functional options.
type outcomeOption func(*OutcomeMutation)

// newOutcomeMutation creates new mutation for the Outcome entity.
func newOutcomeMutation(c config, op Op, opts ...outcomeOption) *OutcomeMutation {
	m := &OutcomeMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcome,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeID sets the ID field of the mutation.
func withOutcomeID(id int) outcomeOption {
	return func(m *OutcomeMutation) {
		var (
			err   error
			once  sync.Once
			value *Outcome
		)
		m.oldValue = func(ctx context.Context) (*Outcome, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Outcome.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcome sets the old Outcome of the mutation.
func withOutcome(node *Outcome) outcomeOption {
	return func(m *OutcomeMutation) {
		m.oldValue = func(context.Context) (*Outcome, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Outcome.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *OutcomeMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *OutcomeMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Outcome entity.
// If the Outcome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *OutcomeMutation) ResetText() {
	m.text = nil
}

// SetCorrect sets the "correct" field.
func (m *OutcomeMutation) SetCorrect(b bool) {
	m.correct = &b
}

// Correct returns the value of the "correct" field in the mutation.
func (m *OutcomeMutation) Correct() (r bool, exists bool) {
	v := m.correct
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrect returns the old "correct" field's value of the Outcome entity.
// If the Outcome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMutation) OldCorrect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrect: %w", err)
	}
	return oldValue.Correct, nil
}

// ResetCorrect resets all changes to the "correct" field.
func (m *OutcomeMutation) ResetCorrect() {
	m.correct = nil
}

// AddProbabilityIDs adds the "probabilities" edge to the Probability entity by ids.
func (m *OutcomeMutation) AddProbabilityIDs(ids ...int) {
	if m.probabilities == nil {
		m.probabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.probabilities[ids[i]] = struct{}{}
	}
}

// ClearProbabilities clears the "probabilities" edge to the Probability entity.
func (m *OutcomeMutation) ClearProbabilities() {
	m.clearedprobabilities = true
}

// ProbabilitiesCleared reports if the "probabilities" edge to the Probability entity was cleared.
func (m *OutcomeMutation) ProbabilitiesCleared() bool {
	return m.clearedprobabilities
}

// RemoveProbabilityIDs removes the "probabilities" edge to the Probability entity by IDs.
func (m *OutcomeMutation) RemoveProbabilityIDs(ids ...int) {
	if m.removedprobabilities == nil {
		m.removedprobabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.probabilities, ids[i])
		m.removedprobabilities[ids[i]] = struct{}{}
	}
}

// RemovedProbabilities returns the removed IDs of the "probabilities" edge to the Probability entity.
func (m *OutcomeMutation) RemovedProbabilitiesIDs() (ids []int) {
	for id := range m.removedprobabilities {
		ids = append(ids, id)
	}
	return
}

// ProbabilitiesIDs returns the "probabilities" edge IDs in the mutation.
func (m *OutcomeMutation) ProbabilitiesIDs() (ids []int) {
	for id := range m.probabilities {
		ids = append(ids, id)
	}
	return
}

// ResetProbabilities resets all changes to the "probabilities" edge.
func (m *OutcomeMutation) ResetProbabilities() {
	m.probabilities = nil
	m.clearedprobabilities = false
	m.removedprobabilities = nil
}

// Where appends a list predicates to the OutcomeMutation builder.
func (m *OutcomeMutation) Where(ps ...predicate.Outcome) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OutcomeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OutcomeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Outcome, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OutcomeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OutcomeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Outcome).
func (m *OutcomeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.text != nil {
		fields = append(fields, outcome.FieldText)
	}
	if m.correct != nil {
		fields = append(fields, outcome.FieldCorrect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcome.FieldText:
		return m.Text()
	case outcome.FieldCorrect:
		return m.Correct()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcome.FieldText:
		return m.OldText(ctx)
	case outcome.FieldCorrect:
		return m.OldCorrect(ctx)
	}
	return nil, fmt.Errorf("unknown Outcome field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcome.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case outcome.FieldCorrect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrect(v)
		return nil
	}
	return fmt.Errorf("unknown Outcome field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Outcome numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Outcome nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeMutation) ResetField(name string) error {
	switch name {
	case outcome.FieldText:
		m.ResetText()
		return nil
	case outcome.FieldCorrect:
		m.ResetCorrect()
		return nil
	}
	return fmt.Errorf("unknown Outcome field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.probabilities != nil {
		edges = append(edges, outcome.EdgeProbabilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcome.EdgeProbabilities:
		ids := make([]ent.Value, 0, len(m.probabilities))
		for id := range m.probabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprobabilities != nil {
		edges = append(edges, outcome.EdgeProbabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcome.EdgeProbabilities:
		ids := make([]ent.Value, 0, len(m.removedprobabilities))
		for id := range m.removedprobabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprobabilities {
		edges = append(edges, outcome.EdgeProbabilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeMutation) EdgeCleared(name string) bool {
	switch name {
	case outcome.EdgeProbabilities:
		return m.clearedprobabilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Outcome unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeMutation) ResetEdge(name string) error {
	switch name {
	case outcome.EdgeProbabilities:
		m.ResetProbabilities()
		return nil
	}
	return fmt.Errorf("unknown Outcome edge %s", name)
}

// ProbabilityMutation represents an operation that mutates the Probability nodes in the graph.
type ProbabilityMutation struct {
	config
	op              Op
	typ             string
	id              *int
	value           *int
	addvalue        *int
	clearedFields   map[string]struct{}
	estimate        *int
	clearedestimate bool
	outcome         *int
	clearedoutcome  bool
	done            bool
	oldValue        func(context.Context) (*Probability, error)
	predicates      []predicate.Probability
}

var _ ent.Mutation = (*ProbabilityMutation)(nil)

// probabilityOption allows management of the mutation configuration using functional options.
type probabilityOption func(*ProbabilityMutation)

// newProbabilityMutation creates new mutation for the Probability entity.
func newProbabilityMutation(c config, op Op, opts ...probabilityOption) *ProbabilityMutation {
	m := &ProbabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeProbability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProbabilityID sets the ID field of the mutation.
func withProbabilityID(id int) probabilityOption {
	return func(m *ProbabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Probability
		)
		m.oldValue = func(ctx context.Context) (*Probability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Probability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProbability sets the old Probability of the mutation.
func withProbability(node *Probability) probabilityOption {
	return func(m *ProbabilityMutation) {
		m.oldValue = func(context.Context) (*Probability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProbabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProbabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProbabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProbabilityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Probability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *ProbabilityMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *ProbabilityMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Probability entity.
// If the Probability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProbabilityMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *ProbabilityMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *ProbabilityMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *ProbabilityMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetEstimateID sets the "estimate" edge to the Estimate entity by id.
func (m *ProbabilityMutation) SetEstimateID(id int) {
	m.estimate = &id
}

// ClearEstimate clears the "estimate" edge to the Estimate entity.
func (m *ProbabilityMutation) ClearEstimate() {
	m.clearedestimate = true
}

// EstimateCleared reports if the "estimate" edge to the Estimate entity was cleared.
func (m *ProbabilityMutation) EstimateCleared() bool {
	return m.clearedestimate
}

// EstimateID returns the "estimate" edge ID in the mutation.
func (m *ProbabilityMutation) EstimateID() (id int, exists bool) {
	if m.estimate != nil {
		return *m.estimate, true
	}
	return
}

// EstimateIDs returns the "estimate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstimateID instead. It exists only for internal usage by the builders.
func (m *ProbabilityMutation) EstimateIDs() (ids []int) {
	if id := m.estimate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstimate resets all changes to the "estimate" edge.
func (m *ProbabilityMutation) ResetEstimate() {
	m.estimate = nil
	m.clearedestimate = false
}

// SetOutcomeID sets the "outcome" edge to the Outcome entity by id.
func (m *ProbabilityMutation) SetOutcomeID(id int) {
	m.outcome = &id
}

// ClearOutcome clears the "outcome" edge to the Outcome entity.
func (m *ProbabilityMutation) ClearOutcome() {
	m.clearedoutcome = true
}

// OutcomeCleared reports if the "outcome" edge to the Outcome entity was cleared.
func (m *ProbabilityMutation) OutcomeCleared() bool {
	return m.clearedoutcome
}

// OutcomeID returns the "outcome" edge ID in the mutation.
func (m *ProbabilityMutation) OutcomeID() (id int, exists bool) {
	if m.outcome != nil {
		return *m.outcome, true
	}
	return
}

// OutcomeIDs returns the "outcome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OutcomeID instead. It exists only for internal usage by the builders.
func (m *ProbabilityMutation) OutcomeIDs() (ids []int) {
	if id := m.outcome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOutcome resets all changes to the "outcome" edge.
func (m *ProbabilityMutation) ResetOutcome() {
	m.outcome = nil
	m.clearedoutcome = false
}

// Where appends a list predicates to the ProbabilityMutation builder.
func (m *ProbabilityMutation) Where(ps ...predicate.Probability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProbabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProbabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Probability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProbabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProbabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Probability).
func (m *ProbabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProbabilityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, probability.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProbabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case probability.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProbabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case probability.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Probability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProbabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case probability.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Probability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProbabilityMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, probability.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProbabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case probability.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProbabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case probability.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Probability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProbabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProbabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProbabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Probability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProbabilityMutation) ResetField(name string) error {
	switch name {
	case probability.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Probability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProbabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.estimate != nil {
		edges = append(edges, probability.EdgeEstimate)
	}
	if m.outcome != nil {
		edges = append(edges, probability.EdgeOutcome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProbabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case probability.EdgeEstimate:
		if id := m.estimate; id != nil {
			return []ent.Value{*id}
		}
	case probability.EdgeOutcome:
		if id := m.outcome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProbabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProbabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProbabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedestimate {
		edges = append(edges, probability.EdgeEstimate)
	}
	if m.clearedoutcome {
		edges = append(edges, probability.EdgeOutcome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProbabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case probability.EdgeEstimate:
		return m.clearedestimate
	case probability.EdgeOutcome:
		return m.clearedoutcome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProbabilityMutation) ClearEdge(name string) error {
	switch name {
	case probability.EdgeEstimate:
		m.ClearEstimate()
		return nil
	case probability.EdgeOutcome:
		m.ClearOutcome()
		return nil
	}
	return fmt.Errorf("unknown Probability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProbabilityMutation) ResetEdge(name string) error {
	switch name {
	case probability.EdgeEstimate:
		m.ResetEstimate()
		return nil
	case probability.EdgeOutcome:
		m.ResetOutcome()
		return nil
	}
	return fmt.Errorf("unknown Probability edge %s", name)
}
