package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"html"
	"time"

	"github.com/cleodora-forecasting/cleodora/cleosrv/dbmodel"
	"github.com/cleodora-forecasting/cleodora/cleosrv/graph/generated"
	"github.com/cleodora-forecasting/cleodora/cleosrv/graph/model"
	"github.com/cleodora-forecasting/cleodora/cleoutils"
	errors2 "github.com/cleodora-forecasting/cleodora/cleoutils/errors"
	"gorm.io/gorm"
)

// CreateForecast is the resolver for the createForecast field.
func (r *mutationResolver) CreateForecast(ctx context.Context, forecast model.NewForecast, estimate model.NewEstimate) (*model.Forecast, error) {
	err := validateNewForecast(&forecast)
	if err != nil {
		return nil, errors2.Wrap(err, "error validating NewForecast")
	}
	// We want the first estimate to have the same 'Created' time as the
	// forecast itself because it's logical that it would be that way.
	estimate.Created = forecast.Created
	err = validateNewEstimate(&estimate, true)
	if err != nil {
		return nil, errors2.Wrap(err, "error validating NewEstimate: %w")
	}
	dbForecast := dbmodel.Forecast{
		Title:       html.EscapeString(forecast.Title),
		Description: html.EscapeString(forecast.Description),
		Created:     *forecast.Created,
		Resolves:    forecast.Resolves,
		Closes:      forecast.Closes,
		Resolution:  dbmodel.ResolutionUnresolved,
		Estimates:   convertNewEstimateToDBEstimate(estimate),
	}

	err = r.db.Transaction(func(tx *gorm.DB) error {
		ret := tx.Create(&dbForecast)
		return ret.Error
	})
	if err != nil {
		return nil, errors2.Newf("creating forecast: %w", err)
	}

	retForecast := model.Forecast{
		ID:          fmt.Sprint(dbForecast.ID),
		Title:       dbForecast.Title,
		Description: dbForecast.Description,
		Created:     dbForecast.Created,
		Resolves:    dbForecast.Resolves,
		Closes:      dbForecast.Closes,
		Resolution:  model.Resolution(dbForecast.Resolution),
		Estimates:   convertEstimatesDBToGQL(dbForecast.Estimates),
	}
	return &retForecast, nil
}

// ResolveForecast is the resolver for the resolveForecast field.
func (r *mutationResolver) ResolveForecast(ctx context.Context, forecastID string, resolution *model.Resolution, correctOutcomeID *string) (*model.Forecast, error) {
	tx := r.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()
	if err := tx.Error; err != nil {
		return nil, errors2.Newf("error creating transaction: %w", err)
	}

	resolutionToSet := dbmodel.ResolutionResolved
	if resolution != nil {
		resolutionToSet = dbmodel.Resolution(*resolution)
	}

	if resolutionToSet == dbmodel.ResolutionUnresolved {
		_ = tx.Rollback()
		return nil, errors2.Newf("resolution %v is not allowed", resolutionToSet)
	}

	if resolutionToSet == dbmodel.ResolutionResolved && correctOutcomeID == nil {
		_ = tx.Rollback()
		return nil, errors2.Newf(
			"to resolve as %v, an Outcome must be specified",
			resolutionToSet,
		)
	}

	forecast := dbmodel.Forecast{}
	ret := tx.Where("id = ?", forecastID).First(&forecast)
	if ret.Error != nil {
		_ = tx.Rollback()
		return nil, errors2.Newf("error getting Forecast with ID %v: %w", forecastID, ret.Error)
	}

	if forecast.Resolution != dbmodel.ResolutionUnresolved {
		_ = tx.Rollback()
		return nil, errors2.New("forecast has already been resolved")
	}

	forecast.Resolution = resolutionToSet
	now := time.Now().UTC()
	if forecast.Resolves.After(now) {
		forecast.Resolves = now
	}
	if forecast.Closes != nil && forecast.Closes.After(now) {
		forecast.Closes = &now
	}
	ret = tx.Save(&forecast)
	if ret.Error != nil {
		_ = tx.Rollback()
		return nil, errors2.Newf("error setting resolution: %w", ret.Error)
	}

	if resolutionToSet == dbmodel.ResolutionResolved {
		outcome := dbmodel.Outcome{}
		ret = tx.Where("id = ?", correctOutcomeID).First(&outcome)
		if ret.Error != nil {
			_ = tx.Rollback()
			return nil, errors2.Newf("error getting outcome: %w", ret.Error)
		}

		matchingForecast := dbmodel.Forecast{}
		ret = tx.Joins(
			"INNER JOIN estimates ON estimates.forecast_id == forecasts.id AND forecasts.id = ?",
			forecastID,
		).Joins(
			"INNER JOIN probabilities ON probabilities.estimate_id == estimates.id",
		).Joins(
			"INNER JOIN outcomes ON outcomes.id == probabilities.outcome_id AND outcomes.id = ?",
			correctOutcomeID,
		).First(&matchingForecast)

		if ret.Error != nil {
			_ = tx.Rollback()
			return nil, errors2.Newf("can't match forecast and outcome: %w", ret.Error)
		}

		if ret.RowsAffected != 1 {
			_ = tx.Rollback()
			return nil, errors2.New("can't match forecast and outcome")
		}

		outcome.Correct = true
		ret = tx.Save(&outcome)
		if ret.Error != nil {
			_ = tx.Rollback()
			return nil, errors2.Newf("error updating outcome: %w", ret.Error)
		}

		type EstimateBrier struct {
			ID    uint
			Brier float64
		}

		var estimateBriers []EstimateBrier

		ret := tx.Table("estimates").
			Select(
				"estimates.id, "+
					"SUM("+
					"(100*outcomes.correct-probabilities.value)*"+
					"(100*outcomes.correct-probabilities.value)/"+
					"10000.0"+
					") as brier",
			).
			Joins(
				"INNER JOIN probabilities ON probabilities.estimate_id=estimates.id",
			).
			Joins(
				"INNER JOIN outcomes ON probabilities.outcome_id=outcomes.id",
			).
			Where("estimates.forecast_id = ?", forecastID).
			Group("estimates.id").
			Scan(&estimateBriers)

		if ret.Error != nil {
			_ = tx.Rollback()
			return nil, errors2.Newf("error calculating brier score: %w", ret.Error)
		}

		for _, r := range estimateBriers {
			ret := tx.Model(&dbmodel.Estimate{}).
				Where("id = ?", r.ID).
				Update("brier_score", r.Brier)
			if ret.Error != nil {
				_ = tx.Rollback()
				return nil, errors2.Newf("error updating brier score: %w", ret.Error)
			}
		}
	}

	// TODO preload uses multiple queries and can be optimized with joins
	ret = tx.Preload("Estimates.Probabilities.Outcome").Find(&forecast)
	if ret.Error != nil {
		_ = tx.Rollback()
		return nil, errors2.Newf("error preloading: %w", ret.Error)
	}

	var estimates []*model.Estimate
	for _, e := range forecast.Estimates {
		var probabilities []*model.Probability
		for _, p := range e.Probabilities {
			probabilities = append(
				probabilities,
				&model.Probability{
					ID:    fmt.Sprint(p.ID),
					Value: p.Value,
					Outcome: &model.Outcome{
						ID:      fmt.Sprint(p.Outcome.ID),
						Text:    p.Outcome.Text,
						Correct: p.Outcome.Correct,
					},
				},
			)
		}
		estimates = append(
			estimates,
			&model.Estimate{
				ID:            fmt.Sprint(e.ID),
				Created:       e.Created,
				Reason:        e.Reason,
				Probabilities: probabilities,
				BrierScore:    e.BrierScore,
			},
		)
	}
	rf := model.Forecast{
		ID:          fmt.Sprint(forecast.ID),
		Title:       forecast.Title,
		Description: forecast.Description,
		Created:     forecast.Created,
		Resolves:    forecast.Resolves,
		Closes:      forecast.Closes,
		Resolution:  model.Resolution(forecast.Resolution),
		Estimates:   estimates,
	}
	ret = tx.Commit()
	if ret.Error != nil {
		return nil, errors2.Newf("error committing: %w", ret.Error)
	}
	return &rf, nil
}

// CreateEstimate is the resolver for the createEstimate field.
func (r *mutationResolver) CreateEstimate(ctx context.Context, forecastID string, estimate model.NewEstimate) (*model.Estimate, error) {
	return r.createEstimate(ctx, forecastID, estimate)
}

// Forecasts is the resolver for the forecasts field.
func (r *queryResolver) Forecasts(ctx context.Context) ([]*model.Forecast, error) {
	// TODO depending on what data is being queried here I guess the query has
	// to return more or less data?
	// https://gqlgen.com/reference/field-collection/
	// fmt.Println(graphql.CollectAllFields(ctx))

	var forecasts []dbmodel.Forecast
	// TODO preload uses multiple queries and can be optimized with joins
	ret := r.db.Preload("Estimates.Probabilities.Outcome").Find(&forecasts)
	if ret.Error != nil {
		return nil, ret.Error
	}

	var retForecasts []*model.Forecast

	for _, f := range forecasts {
		var estimates []*model.Estimate
		for _, e := range f.Estimates {
			var probabilities []*model.Probability
			for _, p := range e.Probabilities {
				probabilities = append(
					probabilities,
					&model.Probability{
						ID:    fmt.Sprint(p.ID),
						Value: p.Value,
						Outcome: &model.Outcome{
							ID:      fmt.Sprint(p.Outcome.ID),
							Text:    p.Outcome.Text,
							Correct: p.Outcome.Correct,
						},
					},
				)
			}
			estimates = append(
				estimates,
				&model.Estimate{
					ID:            fmt.Sprint(e.ID),
					Created:       e.Created,
					Reason:        e.Reason,
					Probabilities: probabilities,
					BrierScore:    e.BrierScore,
				},
			)
		}
		rf := model.Forecast{
			ID:          fmt.Sprint(f.ID),
			Title:       f.Title,
			Description: f.Description,
			Created:     f.Created,
			Resolves:    f.Resolves,
			Closes:      f.Closes,
			Resolution:  model.Resolution(f.Resolution),
			Estimates:   estimates,
		}
		retForecasts = append(retForecasts, &rf)
	}
	return retForecasts, nil
}

// Metadata is the resolver for the metadata field.
func (r *queryResolver) Metadata(ctx context.Context) (*model.Metadata, error) {
	return &model.Metadata{Version: cleoutils.Version}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
