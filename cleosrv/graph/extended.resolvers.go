package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"errors"
	"fmt"
	"html"

	"github.com/cleodora-forecasting/cleodora/cleosrv/ent"
	"github.com/cleodora-forecasting/cleodora/cleosrv/ent/outcome"
	"github.com/cleodora-forecasting/cleodora/cleosrv/graph/generated"
	"github.com/cleodora-forecasting/cleodora/cleosrv/graph/model"
	"github.com/cleodora-forecasting/cleodora/cleoutils"
)

// CreateForecast is the resolver for the createForecast field.
func (r *mutationResolver) CreateForecast(ctx context.Context, forecast ent.CreateForecastInput, estimate ent.CreateEstimateInput) (*ent.Forecast, error) {
	client := ent.FromContext(ctx)
	forecast.Title = html.EscapeString(forecast.Title)
	if forecast.Description != nil {
		safeDescription := html.EscapeString(*forecast.Description)
		forecast.Description = &safeDescription
	}
	if estimate.Reason != nil {
		safeReason := html.EscapeString(*estimate.Reason)
		estimate.Reason = &safeReason
	}
	estimateDb, err := client.Estimate.Create().SetInput(estimate).Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("error creating Estimate in CreateForecast: %w", err)
	}
	return client.Forecast.Create().SetInput(forecast).AddEstimates(estimateDb).Save(ctx)
}

// Metadata is the resolver for the metadata field.
func (r *queryResolver) Metadata(ctx context.Context) (*model.Metadata, error) {
	return &model.Metadata{Version: cleoutils.Version}, nil
}

// Probabilities is the resolver for the probabilities field.
func (r *createEstimateInputResolver) Probabilities(ctx context.Context, obj *ent.CreateEstimateInput, data []*ent.CreateProbabilityInput) error {
	client := ent.FromContext(ctx)

	if len(data) == 0 {
		return errors.New("probabilities can't be empty")
	}

	var outcomeIds []int
	for _, d := range data {
		outcomeIds = append(outcomeIds, *d.OutcomeID)
	}
	outcomes, err := client.Outcome.Query().Where(outcome.IDIn(outcomeIds...)).All(ctx)
	if err != nil {
		return fmt.Errorf("error querying for outcomes: %w", err)
	}
	outcomeMap := map[string]bool{}
	for _, o := range outcomes {
		if _, ok := outcomeMap[o.Text]; ok {
			return fmt.Errorf("outcome '%v' is a duplicate", o.Text)
		}
		outcomeMap[o.Text] = true
	}

	probabilitySum := 0
	builders := make([]*ent.ProbabilityCreate, len(data))
	for i := range data {
		probabilitySum += data[i].Value
		builders[i] = client.Probability.Create().SetInput(*data[i])
	}
	if probabilitySum != 100 {
		return fmt.Errorf("probabilities must add up to 100, not %v", probabilitySum)
	}
	probabilities, err := client.Probability.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return err
	}
	ids := make([]int, len(probabilities))
	for i := range probabilities {
		ids[i] = probabilities[i].ID
	}
	obj.ProbabilityIDs = append(obj.ProbabilityIDs, ids...)
	return nil
}

// Outcome is the resolver for the outcome field.
func (r *createProbabilityInputResolver) Outcome(ctx context.Context, obj *ent.CreateProbabilityInput, data *ent.CreateOutcomeInput) error {
	client := ent.FromContext(ctx)
	data.Text = html.EscapeString(data.Text)
	outcome, err := client.Outcome.Create().SetInput(*data).Save(ctx)
	if err != nil {
		return fmt.Errorf("error creating outcome in Outcome resolver: %w", err)
	}
	obj.OutcomeID = &outcome.ID
	return nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
